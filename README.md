


🔥 실제 서비스에서는 대량 데이터를 조회하기위해 index를 활용하지만 대량의 데이터를 다루지 않는 프로젝트에서는 index를 활용할 기회가 없다.

🔥 그래서, index를 활용한 성능 비교를 통해 index를 경험해보고자 한다.

**공부 기술** : Mysql index



### <시나리오>

1. **데이터 삽입** : 대량의 데이터를 Book 테이블에 삽입하여 검색 성능을 테스트.
2. **인덱스 적용 필드 vs 미적용 필드** : /book/title는 인덱스가 적용된 필드에서 검색 성능을 보여주며, /search/author 인덱스가 없는 필드에서의 성능을 확인.
3. **시간 측정** : postman을 통해 각 검색 쿼리의 성능을 측정하여 인덱스 적용 여부에 따른 차이 비교.
### <프로젝트 구성>
기술스택 : SpringBoot, Spring Data Jpa, Mysql 
### <구현방식>

* ```
  @Table(name = "book", indexes = {
        @Index(name = "idx_title", columnList = "title")
  }
  ```
  
  
  위 코드를 통해 title 필드에 idx를 적용
  
* book 데이터 삽입시 **UUID.randomUUID()**와 **Random()** 을 통해 무작위 book 데이터를 삽입할 수 있는 add_books() 구현

### <Index란?>

index란 데이터베이스에서 **검색속도를 향상시키기 위해** 특정 열이나 열들의 조합에 적용하는 **데이터 구조**이다. 인덱스는 책의 색인처럼 작동하고, 데이터를 빠르게 찾을 수 있게 한다. 

 위에서 말한 데이터 구조는 보통 **B-Tree**와 같은 자료구조(엔진마다 다르지만) 이다. 이를 사용하여 인덱스를 구성한다. 

* **B-Tree**

  *  B-Tree는 데이터를 **균형 있게 분포**시키고, 검색, 삽입, 삭제 시 성능을 유지할 수 있도록 설계된 트리 자료 구조.
  * 이를 통해 데이터를 정렬하고, **이진 탐색**을 적용하여 매우 빠르게 원하는 데이터 검색.

* **인덱스의 장점**

  * 데이터 검색 속도 향상
  * 데이터 정렬 성능 개선 
    * 인덱스를 사용하면 데이터가 이미 정렬된 상태이기 때문에 추가적인 정렬 작업이 불필요

* **인덱스의 단점**

  * 쓰기 작업(insert,update,delete) 성능 저하

    * 데이터 삽입/삭제/수정 시에 인덱스도 함께 갱신되어야 하기 때문에 쓰기 작업에 성능저하가 있을 수 있다. 

  * 디스크 공간 소모

    * 실제로 아래와 같이 **Index_length**를 보면 디스크공간을 차지하는 것을 볼 수 있다.

    <img src=".\README_image\5.png" alt="3" style="zoom:75;" />

  * 선택도가 낮은 경우 효율이 떨어짐
    * 필드의 값이 많이 중복되어 있으면(예: `성별`, `상태값` 등) 인덱스가 효율적으로 작동하지 않는다.

### <성능비교>

* **33만 개** row를 가진 book 테이블 대상으로 성능 비교

* postman을 이용하여 요청과 응답을 받기까지의 시간 확인

  * **단,** MySQL은 동일한 쿼리가 여러 번 실행될 때 **쿼리 캐시(Query Cache)**를 활용해 성능을 개선하기 때문에 첫 쿼리를 대상으로 시간을 확인
  * **`LIKE '%value%'`**와 같은 (부분문자열 조회)패턴은 **인덱스를 무시**하고 **풀 테이블 스캔(full table scan)**을 진행하기 때문에 사용하지 않는다.

  

**인덱스를 적용한 필드**

<img src=".\README_image\2.png" alt="2" style="zoom: 80%;" />![1](.\README_image\1.png)

**인덱스 미적용 필드**

<img src=".\README_image\3.png" alt="3" style="zoom:80%;" />![4](.\README_image\4.png)

| 필드 타입    | 데이터 개수 | 인덱스 적용 여부 | 조회 시간 |
| ------------ | ----------- | ---------------- | --------- |
| **`title`**  | 330,000     | **적용**         | 11 ms     |
| **`author`** | 330,000     | **미적용**       | 177 ms    |

인덱스를 적용한 필드(title)과 인덱스를 적용하지 않은 필드 (author)의 조회 시간 차이는 **15배 이상**이다. 

데이터가 많아질 수록 인덱스를 적용하지 않은 필드의 조회시간은 증가

인덱스를 적용한 필드의 조회 시간은 소폭 증가



### <결론>

성능 비교 결과 인덱스를 적용하는 것이 확실하게 성능 향상에 도움이 되는 것을 알 수 있다.

mysql 의 경우 기본적으로 **full table scan**을 하기 때문에 **이진 탐색**을 사용하는 인덱스는 효율적인 것이다.

**하지만,** 인덱스를 사용할때에는 대규모 데이터에 자주 조회 되는 필드 값을 적절히 찾아 적용해야하고, 메모리와 속도 향상간의 trade off 를 유의해야한다. 